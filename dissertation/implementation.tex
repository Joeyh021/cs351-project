\chapter{Implementation}
\label{ch:implementation}

\section{HDL structure}
Implementation starts from the block diagram described in Chapter \ref{ch:design}, moving from that to laying out the HDL skeleton within Scala. Both Chisel bundles (collections of inputs and outputs used to define interfaces) and Chisel modules are Scala classes, so the layout of the code follows a standard Java/Scala package layout \cite{scala_style}. The top-level package is \txt{dev.joeyh.pio} (the author's domain is \txt{joeyh.dev}), containing the top-level \txt{PIO} module class, and the following sub-packages and files

\begin{itemize}
    \item \txt{execution} - The execution unit and sub-components
          \begin{itemize}
              \item \txt{ExecUnit} - The top-level execution unit
              \item \txt{Decode} - Instruction decoder
              \item \txt{ProgramCounter} - PC register
              \item \txt{Branch} - JUMP execution unit
              \item \txt{Move} - MOV/SET execution unit
              \item \txt{Wait} - WAIT execution unit
          \end{itemize}
    \item \txt{fifo} - FIFOs and reusable interface definitions
          \begin{itemize}
              \item \txt{Fifo} - The FIFO module and sub-components, used for both RX and TX FIFOs
              \item \txt{ProducerIO} - Bundle definition for FIFO producer
              \item \txt{ConsumerIO} - Bundle definition for FIFO consumer
          \end{itemize}
    \item \txt{shiftreg} - Shift registers
          \begin{itemize}
              \item \txt{ISR} - Input shift register
              \item \txt{OSR} - Output shift register
              \item \txt{ShiftRegIO} - Common shift register interface definitions
          \end{itemize}
    \item \txt{memory} - Shift registers
          \begin{itemize}
              \item \txt{CSR} - Control and status register file
              \item \txt{InstructionMem} - 32x16bit Instruction memory
              \item \txt{ScratchReg} - 32-bit scratch register
              \item \txt{Pins} - Pin register and I/O mapping
          \end{itemize}
    \item \txt{util} - Miscellaneous reusable components and utilities
          \begin{itemize}
              \item \txt{Random} - functions for generating random Chisel \txt{UInt}s, used for testing
              \item \txt{ReadWrite} - reusable read and write port interface definitions
          \end{itemize}
\end{itemize}

Some files contain one (or more) Chisel modules, while others contain bundle definitions that are designed to be reused accross multiple modules. Bundles as types is a great feature of Chisel, as it allows to abstract over them using the connection operators. The module hierarchy of the overall design from this is fairly flat, shown in Figure \ref{fig:hdl_hierarchy}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{../img/bd.png}
    \caption{The modular, hierarchical design of the PIO.}
    \label{fig:hdl_hierarchy}
\end{figure}

\section{PIO Components}
\subsection{Execution Unit}

The top-level execution unit wraps the decoder containing most of the logic with the three sub-execution units, which mostly contain very little logic and are wrapped as modules purely for hierarchical abstraction purposes. The module has read/write connections to all of the registers, which are all connected internally to the move module, which is just a big multiplexer between all the registers. The branch register also reads and writes from the registers, as the instruction set includes \txt{x++} and \txt{y++} as branch conditions, meaning that the execution unit includes logic to multiplex writes between those two units to the single write connection to the register.

The 5-bit program counter is also a sub-module of the execution unit. It's output is connected to the instruction memory's address input, and it is able to have a value written by the branch module. It automatically increments each cycle while it's \txt{incrementEnable} input line is high, which allows the instruction decoder to control it to implement delays and stalls.

\subsubsection{Instruction Decoder}

The implementation of the execution unit starts with the instruction decoder, which takes as input the instruction to be decoded, and asserts all the control signals required to execute that instruction. Most of the logic of the decoder is a series of \txt{when}/\txt{otherwise} statements, which are Chisel's equivalent of a behavioural \txt{if}/\txt{else} in Verilog. Listing \ref{lst:decoder} gives an example, where the first block is executed when the opcode is 0 to output the signals to the branch unit otherwise the outputs are all driven low. The mono-directional connection operator \txt{:=} is used to drive the outputs conditionally.

\begin{listing}[h!]
    \vspace{0.5cm}
    \begin{minted}{scala}
when(opcode === 0.U) {
    io.branchOp := instruction(7, 5)
    io.branchAddress := instruction(4, 0)
    io.branchEnable := true.B
}.otherwise {
    io.branchOp := 0.U
    io.branchAddress := 0.U
    io.branchEnable := false.B
}
    \end{minted}
    \caption{Sample code from the instruction decoder}
    \label{lst:decoder}
\end{listing}

The decode module is where delays and stalls are handled. If an instruction includes a delay, the module signals to the program counter not to increment to the next instruction, and the input instruction is substituted for a \txt{MOV null null} which acts as a no-op (\txt{NOP}). An input to the decoder also signals if the previous instruction caused a stall, either signalled externally from the execution unit via an input line or by a \txt{WAIT} instruction waiting on a condition, which will also cause the program counter not to increment and to re-execute the stalled instruction.

The side-set value is decoded within this module and asserted as an output. The side-set value is asserted before an instruction's delay cycles and regardless of whether it stalls or not, so the side-set value of an instruction must be latched such that the side-set of any \txt{NOP} instructions executed while sleeping (waiting for a delay to time out) do not take effect.

Ordinarily such logic would be representable by a D-type latch: the latch is transparent when enabled (not sleeping) and latches the side-set value when disabled, outputting the side-set value of the previous instruction. However, Chisel's timing model and implicit clocking does not make it easy to represent such logic. Synchronous register components are all based on flip-flops instead of latches, meaning that data is moved from input to output only on the rising clock edge

The code required to represent this in Chisel is shown in Listing \ref{lst:side-set}, and the equivalent circuit in Figure \ref{fig:side-set}. The \txt{RegEnable} object represents a single-bit register which is driven by the \txt{sideSet} signal (D goes to Q on the positive clock edge). The register is only write-enabled when the decoder is not in a delay cycle (represented by the \txt{sleeping} signal), and initialised to low on reset. The output side-set value \txt{io.sideSet} is driven by a multiplexer represented by a \txt{Mux} object, which outputs the value of the register if in a delay cycle, otherwise the value decoded directly from the instruction. This emulates a D latch, with the output being the input when not sleeping, and the stored value from the previous cycle when sleeping.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{../img/side-set.png}
    \caption{Logic for latching side-set}
    \label{fig:side-set}
\end{figure}

\begin{listing}[h!]
    \vspace{0.5cm}
    \begin{minted}{scala}
val sideSet    = instruction(12)
val sideSetReg = RegEnable(
    next = sideSet, 
    init = false.B, 
    enable = !sleeping
)
io.sideSet := Mux(sleeping, sideSetReg, sideSet)
    \end{minted}
    \caption{Chisel code for latching side-set}
    \label{lst:side-set}
\end{listing}

\subsection{Shift Registers}

The shift registers are fairly complex: they include logic for reading/writing from/to the FIFOs, as well as logic for shifting bits in and out. There are multiple configuration options too: shift direction, auto push/pull, shift thresholds, etc.


\subsubsection{OSR}

The OSR is the more complicated of the two, as autopull behaves slightly differently from autopush. Hence, there are a number of cases to handle for each instruction which interacts with the OSR.

A \txt{PULL} instruction will cause the OSR to be refilled, and the shift counter to be reset to 0, indicating the OSR is full. If a \txt{PULL} instruction has the `If Empty' flag set, then the pull only takes effect if the shift threshold has been reached, ie, the OSR is empty. If autopull is enabled and the OSR is full, then a \txt{PULL} instruction has no effect.

If an \txt{OUT} instruction is issued, autopull is enabled, and the OSR is empty, then instead of executing an out, the hardware will pull from the fifo and stall, causing the \txt{OUT} to happen on the next cycle. This is because a it cannot \txt{PULL} and then \txt{OUT} the pulled data on the same cycle due to the deep combinational path this would create from the FIFOs straight to the outputs. An \txt{OUT} instruction otherwise shifts the register data in the configured direction by the specified number of bits, putting the N shifted out bits as the least significant bits on the 32-bit output line and filling the register with 0s. The shift count register is also incremented by N. After an \txt{OUT} instruction, an autopull may take place if the shift count register indicates threshold has been met (the OSR is empty) which causes the OSR to be refilled ready for the next \txt{OUT}.

\txt{MOVE} or \txt{SET} instructions may also read/write from the OSR. A read doesn't have any effect on the OSR or FIFO state, but a write to the OSR causes the shift count register to be reset to 0, indicating it has refilled.

This logic is implemented as a lot of chained/nested \txt{when}/\txt{otherwise} blocks, which makes for not the cleanest code, but is the best way to represent the necessary logic. The shift counter value saturates at 32, which can be tricky to work with and hard to consistently get right, so a custom saturating addition operator \txt{+!} is used to perform the threshold checks and increments. Examples is shown in Listing \ref{lst:sat_add}.


\begin{listing}[h!]
    \vspace{0.5cm}
    \begin{minted}{scala}
//add shiftCount to the register, capping the value at 32.
shiftCountReg := shiftCountReg /+\ shiftCount
//boolean condition to check if shift count exceeds threshold
val thresholdReached = (shiftCountReg /+\ shiftCount) >= thresh
    \end{minted}
    \caption{Example usages of the saturating add operator}
    \label{lst:sat_add}
\end{listing}

\subsubsection{ISR}

The ISR is slightly simpler, as there are fewer implications in the interaction between a \txt{IN} instruction and autopush. An \txt{IN} instruction is similar to an \txt{OUT}: the data is shifted by N bits in the configured direction, and the N least significant bits of the input line are placed in the register (as the MSBs if shifting from the right, or LSBs if from the left).

A push may happen in parallel with a shift due to autopush if autopush is enabled and the autopush threshold is reached (the ISR is full). A \txt{PUSH} instruction has the same behaviour as an autopush: write a word to the FIFO and clear the register, resetting the shift count to 0. The `If Empty' flag behaves similarly to the `If Full' flag, only allowing a push to take place if the ISR is full. A push triggered either automatically or by an instruction may stall if the FIFO is full.

\subsection{FIFOs}

The FIFOs are capable of storing up to 4 32-bit words, and buffer data between the PIO system and the rest of the SoC. The complexity in the FIFOs lies in the fact that the PIO and the SoC may operate in different clock domains, meaning the FIFOs must be asynchronous.

discussion of metastability

design ripped from paper

show diagram

talk about


\subsection{Pin Mapping}
pin mapping is way less complex: directions are fixed
\subsection{Other Components}
clock divider
scratch reg
\section{AXI Wrapper}

\section{Chisel Abstractions}